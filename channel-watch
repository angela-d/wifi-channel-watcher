#!/bin/bash

# display extended info (bssid, addl ap's)
DISPLAY_CHANNEL_BSSID="1"
# remaining config values are optional; leave blank if doesn't apply to you
# specify a mac list of internal access points
MAC_LIST=""
# specify a list of access point mac addresses to get custom names, side from manufacturer info
AP_LIST=""
# a resource only accessible from within your enterprise network, for access point bssid caching
INTERNAL_CHECK=""

## end config
# get the channel in use
INTERFACE="$(cat < /proc/net/wireless | awk '{print $1}' | tail -n1 | tr -d .:)"

# wifi active?
if [ "$INTERFACE" == "face" ];
then
  echo "Wifi interface is inactive.  Exiting."
  exit 0
fi

# check if internal resources are accessible, general local cache
[[ ! $INTERNAL_CHECK == ""  && "$(ping -c 1 "$INTERNAL_CHECK")" ]] && INTERNAL_CONN="yes" || INTERNAL_CONN=""
[[ ! -d ~/.config/wifi-channel-watcher/ ]] && mkdir -p ~/.config/wifi-channel-watcher/ && cp icon.svg ~/.config/wifi-channel-watcher/

# MAC address lookup vendor
function macsearch() {
  # look up macs without api keys from IEEE
  # cache this mac address, since it won't change (if the script runs multiple times, no need to make new calls)
  if [ ! -f ~/.config/wifi-channel-watcher/"$1" ];
  then
    LOOKUP=$(echo "$1" | tr -d ':' | head -c 6)

    # cache the mac lookups, this will almost never change so don't litter network requests
    if [ -f ~/.config/wifi-channel-watcher/mac.cache ];
    then
      cat < ~/.config/wifi-channel-watcher/mac.cache | grep -i "$LOOKUP" | cut -d')' -f2 | tr -d '\t' > ~/.config/wifi-channel-watcher/"$LOOKUP"
    else
      if [[ $INTERNAL_CONN == 'yes' ]];
      then
        # no cache exists, pull a copy for a local cache
        curl -L -sS -C - "$MAC_LIST" > ~/.config/wifi-channel-watcher/mac.cache && cat < ~/.config/wifi-channel-watcher/mac.cache | grep -i "$LOOKUP" | cut -d')' -f2 | tr -d '\t' > ~/.config/wifi-channel-watcher/"$LOOKUP"
        sleep 4
      else
        # not on the internal network, obtain from the web and cache it
        curl -L -sS -C - "http://standards-oui.ieee.org/oui.txt" > ~/.config/wifi-channel-watcher/mac.cache && cat < ~/.config/wifi-channel-watcher/mac.cache | grep -i "$LOOKUP" | cut -d')' -f2 | tr -d '\t' > ~/.config/wifi-channel-watcher/"$LOOKUP"
        sleep 4
      fi
    fi
    # if the mac doesn't match a manufacturer, it's probably spoofed
    [ -s ~/.config/wifi-channel-watcher/"$LOOKUP" ] && cat ~/.config/wifi-channel-watcher/"$LOOKUP" || echo "(spoofed)"
  fi
}

# for enterprise lookups, ideal for environments with multiple access points using the same ssid
# and you want to know specifically which ap you're connected to
function apsearch() {
  if [ "$INTERNAL_CONN" == "yes" ];
  then
    AP=$(echo "$1" | tr -d ':')
    AP=$(curl -sS "$AP_LIST" | grep -i "$AP" | head -n1 | awk '{ print $1 }')

    echo "$AP"
  fi
}

# get nearby channel usage
ME="$(/sbin/iwgetid -r)"
CHANNEL="$(/sbin/iw dev "$INTERFACE" info | grep channel | awk '{print $2}')"

# iw scan needs elevation to scan, so nmcli is better to use, otherwise you have an equal amount of work to do to
# pass info to the userspace from root and/or specify sudo privs in visudo
#
# get a channel list into an array (needs work)
IFS=$'\n'
declare -a CHAN=($(nmcli -f chan dev wifi list | sort | uniq -c))

# isolate the active usage
for ACTIVE_CHANNEL in "${CHAN[@]}"
do
  if [[ $ACTIVE_CHANNEL =~ $CHANNEL ]];
  then
    # isolate the total on the active channel
    TOTAL_ACTIVE=$(echo "$ACTIVE_CHANNEL" | awk '{print $1}')
    # it will always be +1 because of me, so subtract
    TOTAL_ACTIVE=$((TOTAL_ACTIVE-1))
  fi
done

# check for notify-send and send a notification to the user
if [ "$TOTAL_ACTIVE" -gt 0 ] && [ -f /usr/bin/notify-send ];
then

  # display the ssid, if enabled
  if [ "$DISPLAY_CHANNEL_BSSID" == "1" ];
  then
    # redundant loop; merge with CHAN at some point
    declare -a DETAILED=($(nmcli -f ssid,bssid,chan,bars dev wifi list | awk -v CHANNEL="$CHANNEL" -v ME="$ME" '$1 != ME && $3 == CHANNEL'))

    for NEIGHBOR in "${DETAILED[@]}"
    do
      SSID="$(printf "%s" "$NEIGHBOR" | awk '{ print $1 }')"
      # ssid is sanitized since it returns values to the screen created by untrusted individuals, because, you never know :)
      [ "$SSID" == "--" ] && SSID="[hidden]" || SSID="${SSID//[^a-zA-Z0-9\_-]/}"
      BSSID="$(printf "%s" "$NEIGHBOR" | awk '{ print $2 }')"
      # get the router manufacturer
      BSSID=$(macsearch "$BSSID")
      BARS="$(printf "%s" "$NEIGHBOR" | awk '{ print $4 }')"
      [[ "$INTERNAL_CONN" == "yes" ]] && AP_NAME=$(apsearch "$BSSID") || AP_NAME=""

      BSSID_DETAIL+="\\n$BARS $SSID - $BSSID\\n$AP_NAME"
    done
  else
    BSSID_DETAIL=""
  fi

  # format the message to prevent notify-send from throwing errors
  PROMPT="$TOTAL_ACTIVE neighboring APs also on channel $CHANNEL\\n$BSSID_DETAIL"

  # send the notification
  notify-send -i ~/.config/wifi-channel-watcher/icon.svg "Wifi Channel Not Optimal" \
  -u critical \ "$PROMPT"
fi
